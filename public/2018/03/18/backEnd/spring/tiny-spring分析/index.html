<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="tiny-spring 分析"><meta name="keywords" content="spring"><meta name="author" content="anan,undefined"><meta name="copyright" content="anan"><title>tiny-spring 分析 | H2O2</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="manifest" href="/manifest.json"><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#FF667B"><meta name="msapplication-TileColor" content="#FF667B"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#FF667B"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-123397569-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC-容器的实现"><span class="toc-number">1.</span> <span class="toc-text">IoC 容器的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件结构"><span class="toc-number">1.1.</span> <span class="toc-text">文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource"><span class="toc-number">1.1.1.</span> <span class="toc-text">Resource</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanDefinition"><span class="toc-number">1.1.2.</span> <span class="toc-text">BeanDefinition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory"><span class="toc-number">1.1.3.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContext"><span class="toc-number">1.1.4.</span> <span class="toc-text">ApplicationContext</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">1.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模板方法模式"><span class="toc-number">1.2.1.</span> <span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代理模式"><span class="toc-number">1.2.2.</span> <span class="toc-text">代理模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-的实现"><span class="toc-number">2.</span> <span class="toc-text">AOP 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重新分析-IoC-容器"><span class="toc-number">2.1.</span> <span class="toc-text">重新分析 IoC 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BeanFactory-的构造与执行"><span class="toc-number">2.1.1.</span> <span class="toc-text">BeanFactory 的构造与执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContext-的构造和执行"><span class="toc-number">2.1.2.</span> <span class="toc-text">ApplicationContext 的构造和执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IoC-实现的一些思考与分析"><span class="toc-number">2.1.3.</span> <span class="toc-text">IoC 实现的一些思考与分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分析-1：AOP-可以在何处被嵌入到-IoC-容器中去？"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">分析 1：AOP 可以在何处被嵌入到 IoC 容器中去？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分析-2：BeanFactory-和-ApplicationContext-设计上的耦合"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">分析 2：BeanFactory 和 ApplicationContext 设计上的耦合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#分析-3：tiny-spring-总体流程的分析"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">分析 3：tiny-spring 总体流程的分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-对动态代理的支持"><span class="toc-number">2.2.</span> <span class="toc-text">JDK 对动态代理的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-的植入与实现细节"><span class="toc-number">2.3.</span> <span class="toc-text">AOP 的植入与实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#在-Bean-初始化过程中完成-AOP-的植入"><span class="toc-number">2.3.1.</span> <span class="toc-text">在 Bean 初始化过程中完成 AOP 的植入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-中动态代理的实现步骤"><span class="toc-number">2.3.2.</span> <span class="toc-text">AOP 中动态代理的实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态代理的内容"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">动态代理的内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#动态代理的步骤"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">动态代理的步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式-1"><span class="toc-number">2.4.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代理模式-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#策略模式"><span class="toc-number">2.4.2.</span> <span class="toc-text">策略模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为-tiny-spring-添加拦截器链"><span class="toc-number">2.5.</span> <span class="toc-text">为 tiny-spring 添加拦截器链</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://avatars2.githubusercontent.com/u/14139937?s=460&amp;v=4"></div><div class="author-info__name text-center">anan</div><div class="author-info__description text-center">unstable hydrogen peroxide</div><div class="follow-button"><a href="https://github.com/Zakariyya">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">14</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="url">Name</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">H2O2</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">tiny-spring 分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java-Program/">java Program</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2018/03/18/backEnd/spring/tiny-spring分析/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2018/03/18/backEnd/spring/tiny-spring分析/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">4,451</span><span class="post-meta__separator">|</span><span>Reading time: 15 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>—— 转载自D佬笔记：<a href="https://www.zybuluo.com/dugu9sword/note/382745" target="_blank" rel="noopener">原文</a></p>
<p><strong>前言</strong></p>
<p>在阅读 Spring 的源代码（依赖注入部分和面向切面编程部分）时遇到不少困惑，庞大的类文件结构、纷繁复杂的方法调用、波诡云谲的多态实现，让自己深陷其中、一头雾水。<br>后来注意到 <a href="https://github.com/code4craft" target="_blank" rel="noopener">code4craft</a> 的 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 项目，实现了一个微型的 Spring，提供对 IoC 和 AOP 的最基本支持，麻雀虽小，五脏俱全，对 Spring 的认知清晰了不少。这个微型框架的结构包括文件名、方法名都是参照 Spring 来实现的，对于初读 Spring 的学习者，作为研究 Spring 的辅助工具应该能够受益匪浅。<br>在研究 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 的时候，收获颇多，把对这个微型框架的一些分析写了下来，行文可能有点紊乱。</p>
<p><strong>本文结构</strong></p>
<ol>
<li>第一部分 <strong>IoC 容器的实现</strong> 对应了 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 的 <a href="https://github.com/code4craft/tiny-spring/releases" target="_blank" rel="noopener">step-1</a> 到 <a href="https://github.com/code4craft/tiny-spring/releases" target="_blank" rel="noopener">step-5</a> 部分，这 5 个 step 实现了基本的 IoC 容器，支持singleton类型的bean，包括初始化、属性注入、以及依赖 Bean 注入，可从 XML 中读取配置，XML 读取方式没有具体深入。</li>
<li>第二部分 <strong>AOP 容器的实现</strong> 对应了 <a href="https://github.com/code4craft/tiny-spring" target="_blank" rel="noopener">tiny-spring</a> 的 <a href="https://github.com/code4craft/tiny-spring/releases" target="_blank" rel="noopener">step-6</a> 到 <a href="https://github.com/code4craft/tiny-spring/releases" target="_blank" rel="noopener">step-9</a> 部分。<a href="https://github.com/code4craft/tiny-spring/releases" target="_blank" rel="noopener">step-10</a> 中对 cglib 的支持没有分析。这 4 个 step 可以使用 AspectJ 的语法进行 AOP 编写，支持接口代理。考虑到 AspectJ 语法仅用于实现 <code>execution(&quot;***&quot;)</code> 部分的解析，不是主要内容，也可以使用 Java 的正则表达式粗略地完成，因此没有关注这些细节。</li>
</ol>
<p><strong>参考书目</strong><br>《Spring 实战》《Spring 技术内幕》</p>
<hr>
<p>tiny-spring 分析</p>
<ul>
<li>IoC 容器的实现<ul>
<li>文件结构<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#resource" target="_blank" rel="noopener">Resource</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beandefinition" target="_blank" rel="noopener">BeanDefinition</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beanfactory" target="_blank" rel="noopener">BeanFactory</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#applicationcontext" target="_blank" rel="noopener">ApplicationContext</a></li>
</ul>
</li>
<li>设计模式<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">模板方法模式</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">代理模式</a></li>
</ul>
</li>
</ul>
</li>
<li>AOP 的实现<ul>
<li>重新分析 IoC 容器<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#beanfactory-%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">BeanFactory 的构造与执行</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#applicationcontext-%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">ApplicationContext 的构造和执行</a></li>
<li>IoC 实现的一些思考与分析<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%88%86%E6%9E%90-1aop-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BD%95%E5%A4%84%E8%A2%AB%E5%B5%8C%E5%85%A5%E5%88%B0-ioc-%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8E%BB" target="_blank" rel="noopener">分析 1：AOP 可以在何处被嵌入到 IoC 容器中去？</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%88%86%E6%9E%90-2beanfactory-%E5%92%8C-applicationcontext-%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E8%80%A6%E5%90%88" target="_blank" rel="noopener">分析 2：BeanFactory 和 ApplicationContext 设计上的耦合</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%88%86%E6%9E%90-3tiny-spring-%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B%E7%9A%84%E5%88%86%E6%9E%90" target="_blank" rel="noopener">分析 3：tiny-spring 总体流程的分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#jdk-%E5%AF%B9%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%94%AF%E6%8C%81" target="_blank" rel="noopener">JDK 对动态代理的支持</a></li>
<li>AOP 的植入与实现细节<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%9C%A8-bean-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AE%8C%E6%88%90-aop-%E7%9A%84%E6%A4%8D%E5%85%A5" target="_blank" rel="noopener">在 Bean 初始化过程中完成 AOP 的植入</a></li>
<li>AOP 中动态代理的实现步骤<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%86%85%E5%AE%B9" target="_blank" rel="noopener">动态代理的内容</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%AD%A5%E9%AA%A4" target="_blank" rel="noopener">动态代理的步骤</a></li>
</ul>
</li>
</ul>
</li>
<li>设计模式<ul>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1" target="_blank" rel="noopener">代理模式</a></li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">策略模式</a></li>
</ul>
</li>
<li><a href="https://www.zybuluo.com/dugu9sword/note/382745#%E4%B8%BA-tiny-spring-%E6%B7%BB%E5%8A%A0%E6%8B%A6%E6%88%AA%E5%99%A8%E9%93%BE" target="_blank" rel="noopener">为 tiny-spring 添加拦截器链</a></li>
</ul>
</li>
</ul>
<h2 id="IoC-容器的实现"><a href="#IoC-容器的实现" class="headerlink" title="IoC 容器的实现"></a>IoC 容器的实现</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><h4 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h4><p>以 <code>Resource</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器中的内容从哪里来的问题，也就是 <strong>配置文件从哪里读取、配置文件如何读取</strong> 的问题。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Resource</code></td>
<td>接口，标识一个外部资源。通过 <code>getInputStream()</code> 方法 <strong>获取资源的输入流</strong> 。</td>
</tr>
<tr>
<td><code>UrlResource</code></td>
<td>实现 <code>Resource</code> 接口的资源类，通过 URL 获取资源。</td>
</tr>
<tr>
<td><code>ResourceLoader</code></td>
<td>资源加载类。通过 <code>getResource(String)</code> 方法获取一个 <code>Resouce</code> 对象，是 <strong>获取 Resouce 的主要途径</strong> 。</td>
</tr>
</tbody>
</table>
<p><em>注：</em> 这里在设计上有一定的问题，<code>ResourceLoader</code> 直接返回了一个 <code>UrlResource</code>，更好的方法是声明一个 <code>ResourceLoader</code> 接口，再实现一个 <code>UrlResourceLoader</code> 类用于加载 <code>UrlResource</code>。</p>
<h4 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h4><p>以 <code>BeanDefinition</code> 类为核心发散出的几个类，都是用于解决 <code>Bean</code> 的具体定义问题，包括 <code>Bean</code> 的名字是什么、它的类型是什么，它的属性赋予了哪些值或者引用，也就是 <strong>如何在 IoC 容器中定义一个 Bean，使得 IoC 容器可以根据这个定义来生成实例</strong> 的问题。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BeanDefinition</code></td>
<td>该类保存了 <code>Bean</code> 定义。包括 <code>Bean</code> 的 <strong>名字</strong> <code>String beanClassName</code>、<strong>类型</strong><code>Class beanClass</code>、<strong>属性</strong> <code>PropertyValues propertyValues</code>。根据其 <strong>类型</strong> 可以生成一个类实例，然后可以把 <strong>属性</strong> 注入进去。<code>propertyValues</code> 里面包含了一个个 <code>PropertyValue</code> 条目，每个条目都是键值对 <code>String</code> - <code>Object</code>，分别对应要生成实例的属性的名字与类型。在 Spring 的 XML 中的 <code>property</code> 中，键是 <code>key</code> ，值是 <code>value</code> 或者 <code>ref</code>。对于 <code>value</code> 只要直接注入属性就行了，但是 <code>ref</code> 要先进行解析。<code>Object</code> 如果是 <code>BeanReference</code> 类型，则说明其是一个引用，其中保存了引用的名字，需要用先进行解析，转化为对应的实际 <code>Object</code>。</td>
</tr>
<tr>
<td><code>BeanDefinitionReader</code></td>
<td>解析 <code>BeanDefinition</code> 的接口。通过 <code>loadBeanDefinitions(String)</code> 来从一个地址加载类定义。</td>
</tr>
<tr>
<td><code>AbstractBeanDefinitionReader</code></td>
<td>实现 <code>BeanDefinitionReader</code> 接口的抽象类（未具体实现 <code>loadBeanDefinitions</code>，而是规范了 <code>BeanDefinitionReader</code> 的基本结构）。内置一个 <code>HashMap rigistry</code>，用于保存 <code>String</code> - <code>beanDefinition</code> 的键值对。内置一个 <code>ResourceLoader resourceLoader</code>，用于保存类加载器。用意在于，使用时，只需要向其 <code>loadBeanDefinitions()</code> 传入一个资源地址，就可以自动调用其类加载器，并把解析到的 <code>BeanDefinition</code> 保存到 <code>registry</code> 中去。</td>
</tr>
<tr>
<td><code>XmlBeanDefinitionReader</code></td>
<td>具体实现了 <code>loadBeanDefinitions()</code> 方法，从 XML 文件中读取类定义。</td>
</tr>
</tbody>
</table>
<h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><p>以 <code>BeanFactory</code> 接口为核心发散出的几个类，都是用于解决 IoC 容器在 <strong>已经获取 Bean 的定义的情况下，如何装配、获取 Bean 实例</strong> 的问题。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BeanFactory</code></td>
<td>接口，标识一个 IoC 容器。通过 <code>getBean(String)</code> 方法来 <strong>获取一个对象</strong></td>
</tr>
<tr>
<td><code>AbstractBeanFactory</code></td>
<td><code>BeanFactory</code> 的一种抽象类实现，规范了 IoC 容器的基本结构，但是把生成 <code>Bean</code>的具体实现方式留给子类实现。IoC 容器的结构：<code>AbstractBeanFactory</code> 维护一个 <code>beanDefinitionMap</code> 哈希表用于保存类的定义信息（<code>BeanDefinition</code>）。获取 <code>Bean</code> 时，如果 <code>Bean</code> 已经存在于容器中，则返回之，否则则调用 <code>doCreateBean</code>方法装配一个 <code>Bean</code>。（所谓存在于容器中，是指容器可以通过 <code>beanDefinitionMap</code> 获取 <code>BeanDefinition</code> 进而通过其 <code>getBean()</code> 方法获取 <code>Bean</code>。）</td>
</tr>
<tr>
<td><code>AutowireCapableBeanFactory</code></td>
<td>可以实现自动装配的 <code>BeanFactory</code>。在这个工厂中，实现了 <code>doCreateBean</code> 方法，该方法分三步：1，通过 <code>BeanDefinition</code> 中保存的类信息实例化一个对象；2，把对象保存在 <code>BeanDefinition</code> 中，以备下次获取；3，为其装配属性。装配属性时，通过 <code>BeanDefinition</code> 中维护的 <code>PropertyValues</code> 集合类，把 <code>String</code> - <code>Value</code> 键值对注入到 <code>Bean</code> 的属性中去。如果 <code>Value</code> 的类型是 <code>BeanReference</code>则说明其是一个引用（对应于 XML 中的 <code>ref</code>），通过 <code>getBean</code> 对其进行获取，然后注入到属性中。</td>
</tr>
</tbody>
</table>
<h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><p>以 <code>ApplicationContext</code> 接口为核心发散出的几个类，主要是对前面 <code>Resouce</code> 、 <code>BeanFactory</code>、<code>BeanDefinition</code> 进行了功能的封装，解决 <strong>根据地址获取 IoC 容器并使用</strong> 的问题。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ApplicationContext</code></td>
<td>标记接口，继承了 <code>BeanFactory</code>。通常，要实现一个 IoC 容器时，需要先通过 <code>ResourceLoader</code> 获取一个 <code>Resource</code>，其中包括了容器的配置、<code>Bean</code> 的定义信息。接着，使用 <code>BeanDefinitionReader</code> 读取该 <code>Resource</code> 中的 <code>BeanDefinition</code> 信息。最后，把 <code>BeanDefinition</code> 保存在 <code>BeanFactory</code>中，容器配置完毕可以使用。注意到 <code>BeanFactory</code> 只实现了 <code>Bean</code> 的 <strong>装配、获取</strong>，并未说明 <code>Bean</code> 的 <strong>来源</strong> 也就是 <code>BeanDefinition</code> 是如何 <strong>加载</strong> 的。该接口把 <code>BeanFactory</code> 和 <code>BeanDefinitionReader</code> 结合在了一起。</td>
</tr>
<tr>
<td><code>AbstractApplicationContext</code></td>
<td><code>ApplicationContext</code> 的抽象实现，内部包含一个 <code>BeanFactory</code> 类。主要方法有 <code>getBean()</code> 和 <code>refresh()</code> 方法。<code>getBean()</code> 直接调用了内置 <code>BeanFactory</code> 的 <code>getBean()</code> 方法，<code>refresh()</code> 则用于实现 <code>BeanFactory</code> 的刷新，也就是告诉 <code>BeanFactory</code> 该使用哪个资源（<code>Resource</code>）加载类定义（<code>BeanDefinition</code>）信息，该方法留给子类实现，用以实现 <strong>从不同来源的不同类型的资源加载类定义</strong> 的效果。</td>
</tr>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>从类路径加载资源的具体实现类。内部通过 <code>XmlBeanDefinitionReader</code> 解析 <code>UrlResourceLoader</code> 读取到的 <code>Resource</code>，获取 <code>BeanDefinition</code> 信息，然后将其保存到内置的 <code>BeanFactory</code> 中。</td>
</tr>
</tbody>
</table>
<p><em>注 1：</em>在 Spring 的实现中，对 <code>ApplicatinoContext</code> 的分层更为细致。<code>AbstractApplicationContext</code> 中为了实现 <strong>不同来源</strong> 的 <strong>不同类型</strong> 的资源加载类定义，把这两步分层实现。以“从类路径读取 XML 定义”为例，首先使用 <code>AbstractXmlApplicationContext</code> 来实现 <strong>不同类型</strong> 的资源解析，接着，通过 <code>ClassPathXmlApplicationContext</code> 来实现 <strong>不同来源</strong> 的资源解析。<br><em>注 2：</em>在 tiny-spring 的实现中，先用 <code>BeanDefinitionReader</code> 读取 <code>BeanDefiniton</code> 后，保存在内置的 <code>registry</code>（键值对为 <code>String</code> - <code>BeanDefinition</code> 的哈希表，通过 <code>getRigistry()</code> 获取）中，然后由 <code>ApplicationContext</code> 把 <code>BeanDefinitionReader</code> 中 <code>registry</code> 的键值对一个个赋值给 <code>BeanFactory</code> 中保存的 <code>beanDefinitionMap</code>。而在 Spring 的实现中，<code>BeanDefinitionReader</code> 直接操作 <code>BeanDefinition</code> ，它的 <code>getRegistry()</code> 获取的不是内置的 <code>registry</code>，而是 <code>BeanFactory</code> 的实例。如何实现呢？以 <code>DefaultListableBeanFactory</code> 为例，它实现了一个 <code>BeanDefinitonRigistry</code> 接口，该接口把 <code>BeanDefinition</code> 的 <strong>注册</strong> 、<strong>获取</strong> 等方法都暴露了出来，这样，<code>BeanDefinitionReader</code> 可以直接通过这些方法把 <code>BeanDefiniton</code> 直接加载到 <code>BeanFactory</code> 中去。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><em>注：此处的设计模式分析不限于 tiny-spring，也包括 Spring 本身的内容</em></p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>该模式大量使用，例如在 <code>BeanFactory</code> 中，把 <code>getBean()</code> 交给子类实现，不同的子类 <code>**BeanFactory</code> 对其可以采取不同的实现。</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>在 tiny-spring 中（Spring 中也有类似但不完全相同的实现方式），<code>ApplicationContext</code> 继承了 <code>BeanFactory</code> 接口，具备了 <code>getBean()</code> 功能，但是又内置了一个 <code>BeanFactory</code> 实例，<code>getBean()</code> 直接调用 <code>BeanFactory</code> 的 <code>getBean()</code> 。但是<code>ApplicationContext</code> 加强了 <code>BeanFactory</code>，它把类定义的加载也包含进去了。</p>
<h2 id="AOP-的实现"><a href="#AOP-的实现" class="headerlink" title="AOP 的实现"></a>AOP 的实现</h2><h3 id="重新分析-IoC-容器"><a href="#重新分析-IoC-容器" class="headerlink" title="重新分析 IoC 容器"></a>重新分析 IoC 容器</h3><p><em>注：以下所说的 BeanFactory 和 ApplicationContext 不是指的那几个最基本的接口类（例如 BeanFactory 接口，它除了 getBean 空方法之外，什么都没有，无法用来分析。），而是指这一类对象总体的表现，比如 ClasspathXmlApplicationContext、FileSystemXmlApplicationContext 都算是 ApplicationContext。</em></p>
<h4 id="BeanFactory-的构造与执行"><a href="#BeanFactory-的构造与执行" class="headerlink" title="BeanFactory 的构造与执行"></a>BeanFactory 的构造与执行</h4><p><code>BeanFactory</code> 的核心方法是 <code>getBean(String)</code> 方法，用于从工厂中取出所需要的 <code>Bean</code> 。<code>AbstractBeanFactory</code> 规定了基本的构造和执行流程。</p>
<p><code>getBean</code> 的流程：<em>包括实例化和初始化，也就是生成 Bean，再执行一些初始化操作。</em></p>
<ol>
<li><code>doCreateBean</code> ：实例化 <code>Bean</code>。<br>a. <code>createInstance</code> ：生成一个新的实例。<br>b. <code>applyProperties</code> ：注入属性，包括依赖注入的过程。在依赖注入的过程中，如果 <code>Bean</code> 实现了 <code>BeanFactoryAware</code> 接口，则将容器的引用传入到 <code>Bean</code> 中去，这样，<code>Bean</code> 将获取对容器操作的权限，也就允许了 <strong>编写扩展 IoC 容器的功能的 Bean</strong>。</li>
<li><code>initializeBean(bean)</code> ： 初始化 <code>Bean</code>。<br>a. 从 <code>BeanPostProcessor</code> 列表中，依次取出 <code>BeanPostProcessor</code> 执行 <code>bean = postProcessBeforeInitialization(bean,beanName)</code> 。（<em>为什么调用 BeanPostProceesor 中提供方法时，不是直接 post…(bean,beanName) 而是 bean = post…(bean,beanName) 呢？见分析1 。另外，BeanPostProcessor 列表的获取有问题，见分析2。</em>）<br>b. 初始化方法（tiny-spring 未实现对初始化方法的支持）。<br>c. 从 <code>BeanPostProcessor</code> 列表中， 依次取出 <code>BeanPostProcessor</code> 执行其 <code>bean = postProcessAfterInitialization(bean,beanName)</code>。</li>
</ol>
<h4 id="ApplicationContext-的构造和执行"><a href="#ApplicationContext-的构造和执行" class="headerlink" title="ApplicationContext 的构造和执行"></a>ApplicationContext 的构造和执行</h4><p><code>ApplicationContext</code> 的核心方法是 <code>refresh()</code> 方法，用于从资源文件加载类定义、扩展容器的功能。</p>
<p><code>refresh</code> 的流程：</p>
<ol>
<li><code>loadBeanDefinitions(BeanFactory)</code> ：加载类定义，并注入到内置的 <code>BeanFactory</code> 中，这里的可扩展性在于，<strong>未对加载方法进行要求，也就是可以从不同来源的不同类型的资源进行加载</strong>。</li>
<li><code>registerBeanPostProcessors(BeanFactory)</code> ：获取所有的 <code>BeanPostProcessor</code>，并注册到 <code>BeanFactory</code> 维护的 <code>BeanPostProcessor</code> 列表去。</li>
<li><code>onRefresh</code> ：<br>a. <code>preInstantiateSingletons</code> ：以单例的方式，初始化所有 <code>Bean</code>。tiny-spring 只支持 <code>singleton</code> 模式。</li>
</ol>
<h4 id="IoC-实现的一些思考与分析"><a href="#IoC-实现的一些思考与分析" class="headerlink" title="IoC 实现的一些思考与分析"></a>IoC 实现的一些思考与分析</h4><h5 id="分析-1：AOP-可以在何处被嵌入到-IoC-容器中去？"><a href="#分析-1：AOP-可以在何处被嵌入到-IoC-容器中去？" class="headerlink" title="分析 1：AOP 可以在何处被嵌入到 IoC 容器中去？"></a>分析 1：AOP 可以在何处被嵌入到 IoC 容器中去？</h5><p>在 <code>Bean</code> 的初始化过程中，会调用 <code>BeanPostProcessor</code> 对其进行一些处理。在它的 <code>postProcess...Initialization</code>方法中返回了一个 <code>Bean</code>，这个返回的 <code>Bean</code> 可能已经不是原来传入的 <code>Bean</code> 了，<strong>这为实现 AOP 的代理提供了可能</strong>！以 JDK 提供的动态代理为例，假设方法要求传入的对象实现了 <code>IObj</code> 接口，实际传入的对象是 <code>Obj</code>，那么在方法中，通过动态代理，可以 <strong>生成一个实现了 IObj 接口并把 Obj 作为内置对象的代理类 Proxy 返回</strong>，此时 <code>Bean</code> 已经被偷偷换成了它的代理类。</p>
<h5 id="分析-2：BeanFactory-和-ApplicationContext-设计上的耦合"><a href="#分析-2：BeanFactory-和-ApplicationContext-设计上的耦合" class="headerlink" title="分析 2：BeanFactory 和 ApplicationContext 设计上的耦合"></a>分析 2：BeanFactory 和 ApplicationContext 设计上的耦合</h5><p><code>BeanFactory</code> 中的 <code>BeanPostProcessor</code> 的列表是哪里生成的呢？是在 <code>ApplicationContext</code> 中的 <code>refresh</code> 方法的第二步，这里设计上应该有些问题，按理说 <code>ApplicationContext</code> 是基于 <code>BeanFactory</code> 的，<code>BeanFactory</code> 的属性的获取，怎么能依赖于 <code>ApplicationContext</code> 的调用呢？</p>
<h5 id="分析-3：tiny-spring-总体流程的分析"><a href="#分析-3：tiny-spring-总体流程的分析" class="headerlink" title="分析 3：tiny-spring 总体流程的分析"></a>分析 3：tiny-spring 总体流程的分析</h5><p>总体来说，tiny-spring 的 <code>ApplicaitonContext</code> 使用流程是这样的： </p>
<ol>
<li><code>ApplicationContext</code> 完成了类定义的读取和加载，并注册到 <code>BeanFactory</code> 中去。 </li>
<li><code>ApplicationContext</code> 从 <code>BeanFactory</code> 中寻找 <code>BeanPostProcessor</code>，注册到 <code>BeanFactory</code><br>维护的 <code>BeanPostProcessor</code> 列表中去。 </li>
<li><code>ApplicationContext</code> 以单例的模式，通过主动调用 <code>getBean</code> 实例化、注入属性、然后初始化 <code>BeanFactory</code> 中所有的 <code>Bean</code>。由于所有的 <code>BeanPostProcessor</code> 都已经在第 2 步中完成实例化了，因此接下来实例化的是普通 <code>Bean</code>，因此普通 <code>Bean</code> 的初始化过程可以正常执行。<br>\4. 调用 <code>getBean</code> 时，委托给 <code>BeanFactory</code>，此时只是简单的返回每个 <code>Bean</code> 单例，因为所有的 <code>Bean</code> 实例在第三步都已经生成了。</li>
</ol>
<h3 id="JDK-对动态代理的支持"><a href="#JDK-对动态代理的支持" class="headerlink" title="JDK 对动态代理的支持"></a>JDK 对动态代理的支持</h3><p>JDK 中几个关键的类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Proxy</code></td>
<td>来自 JDK API。提供生成对象的动态代理的功能，通过<code>Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>方法返回一个代理对象。</td>
</tr>
<tr>
<td><code>InvocationHandler</code></td>
<td>来自 JDK API。通过 <code>Object invoke(Object proxy, Method method,Object[] args)</code> 方法实现代理对象中方法的调用和其他处理。</td>
</tr>
</tbody>
</table>
<p>假设以下的情况：</p>
<ul>
<li>对象 <code>obj</code> 实现了 <code>IObj</code> 接口，接口中有一个方法 <code>func(Object[] args)</code>。</li>
<li>对象 <code>handler</code> 是 <code>InvocationHandler</code> 的实例。</li>
</ul>
<p>那么，通过 <code>Proxy</code> 的 <code>newProxyInstance(obj.getClassLoader(), obj.getClass().getInterfaces(), handler</code>，可以返回 <code>obj</code> 的代理对象 <code>proxy</code>。</p>
<p>当调用 <code>proxy.func(args)</code> 时，对象内部将委托给 <code>handler.invoke(proxy, func, args)</code> 函数实现。</p>
<p>因此，<strong>在 handler 的 invoke 中，可以完成对方法拦截的处理</strong>。可以先判断是不是要拦截的方法，如果是，进行拦截（比如先做一些操作，再调用原来的方法，对应了 Spring 中的前置通知）；如果不是，则直接调用原来的方法。</p>
<h3 id="AOP-的植入与实现细节"><a href="#AOP-的植入与实现细节" class="headerlink" title="AOP 的植入与实现细节"></a>AOP 的植入与实现细节</h3><h4 id="在-Bean-初始化过程中完成-AOP-的植入"><a href="#在-Bean-初始化过程中完成-AOP-的植入" class="headerlink" title="在 Bean 初始化过程中完成 AOP 的植入"></a>在 <code>Bean</code> 初始化过程中完成 AOP 的植入</h4><p>解决 AOP 的植入问题，首先要解决 <strong>在 IoC 容器的何处植入 AOP</strong> 的问题，其次要解决 <strong>为哪些对象提供 AOP 的植入</strong> 的问题。<br>tiny-spring 中 <code>AspectJAwareAdvisorAutoProxyCreator</code> 类（以下简称 <code>AutoProxyCreator</code>）是实现 AOP 植入的关键类，它实现了两个接口：</p>
<ol>
<li><code>BeanPostProcessor</code> ：在 <code>postProcessorAfterInitialization</code> 方法中，使用动态代理的方式，返回一个对象的代理对象。解决了 <strong>在 IoC 容器的何处植入 AOP</strong> 的问题。</li>
<li><code>BeanFactoryAware</code> ：这个接口提供了对 <code>BeanFactory</code> 的感知，这样，尽管它是容器中的一个 <code>Bean</code>，却可以获取容器的引用，进而获取容器中所有的切点对象，决定对哪些对象的哪些方法进行代理。解决了 <strong>为哪些对象提供 AOP 的植入</strong> 的问题。</li>
</ol>
<h4 id="AOP-中动态代理的实现步骤"><a href="#AOP-中动态代理的实现步骤" class="headerlink" title="AOP 中动态代理的实现步骤"></a>AOP 中动态代理的实现步骤</h4><h5 id="动态代理的内容"><a href="#动态代理的内容" class="headerlink" title="动态代理的内容"></a>动态代理的内容</h5><p>首先，要知道动态代理的内容（拦截哪个对象、在哪个方法拦截、拦截具体内容），下面是几个关键的类：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PointcutAdvisor</code></td>
<td>切点通知器，用于提供 <strong>对哪个对象的哪个方法进行什么样的拦截</strong> 的具体内容。通过它可以获取一个切点对象 <code>Pointcut</code> 和一个通知器对象 <code>Advisor</code>。</td>
</tr>
<tr>
<td><code>Pointcut</code></td>
<td>切点对象可以获取一个 <code>ClassFilter</code> 对象和一个 <code>MethodMatcher</code> 对象。前者用于判断是否对某个对象进行拦截（用于 <strong>筛选要代理的目标对象</strong>），后者用于判断是否对某个方法进行拦截（用于 <strong>在代理对象中对不同的方法进行不同的操作</strong>）。</td>
</tr>
<tr>
<td><code>Advisor</code></td>
<td>通知器对象可以获取一个通知对象 <code>Advice</code> 。就是用于实现 <strong>具体的方法拦截</strong>，需要使用者编写，也就对应了 Spring 中的前置通知、后置通知、环切通知等。</td>
</tr>
</tbody>
</table>
<h5 id="动态代理的步骤"><a href="#动态代理的步骤" class="headerlink" title="动态代理的步骤"></a>动态代理的步骤</h5><p>接着要知道动态代理的步骤：</p>
<ol>
<li><code>AutoProxyCreator</code>（实现了 <code>BeanPostProcessor</code> 接口）在实例化所有的 <code>Bean</code> 前，最先被实例化。</li>
<li>其他普通 <code>Bean</code> 被实例化、初始化，在初始化的过程中，<code>AutoProxyCreator</code> 加载 <code>BeanFactory</code> 中所有的 <code>PointcutAdvisor</code>（这也保证了 <code>PointcutAdvisor</code> 的实例化顺序优于普通 <code>Bean</code>。），然后依次使用 <code>PointcutAdvisor</code> 内置的 <code>ClassFilter</code>，判断当前对象是不是要拦截的类。</li>
<li>如果是，则生成一个 <code>TargetSource</code>（要拦截的对象和其类型），并取出 <code>AutoProxyCreator</code> 的 <code>MethodMatcher</code>（对哪些方法进行拦截）、<code>Advice</code>（拦截的具体操作），再，交给 <code>AopProxy</code> 去生成代理对象。</li>
<li><code>AopProxy</code> 生成一个 <code>InvocationHandler</code>，在它的 <code>invoke</code> 函数中，首先使用 <code>MethodMatcher</code> 判断是不是要拦截的方法，如果是则交给 <code>Advice</code> 来执行（<code>Advice</code> 由用户来编写，其中也要手动/自动调用原始对象的方法），如果不是，则直接交给 <code>TargetSource</code> 的原始对象来执行。</li>
</ol>
<h3 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h4><p>通过动态代理实现，见分析1中的内容，不再赘述。</p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>生成代理对象时，可以使用 JDK 的动态代理和 Cglib 的动态代理，对于不同的需求可以委托给不同的类实现。</p>
<h3 id="为-tiny-spring-添加拦截器链"><a href="#为-tiny-spring-添加拦截器链" class="headerlink" title="为 tiny-spring 添加拦截器链"></a>为 tiny-spring 添加拦截器链</h3><p>tiny-spring 不支持拦截器链，可以模仿 Spring 中拦截器链的实现，实现对多拦截器的支持。<br>tiny-spring 中的 <code>proceed()</code> 方法是调用原始对象的方法 <code>method.invoke(object,args)</code>。（参见 <code>ReflectiveMethodInvocation</code> 类)<br>为了支持多拦截器，做出以下修改：</p>
<ul>
<li>将 <code>proceed()</code> 方法修改为调用代理对象的方法 <code>method.invoke(proxy,args)</code>。</li>
<li>在代理对象的 <code>InvocationHandler</code> 的 <code>invoke</code> 函数中，查看拦截器列表，如果有拦截器，则调用第一个拦截器并返回，否则调用原始对象的方法。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">anan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://zakariyya.github.io/2018/03/18/backEnd/spring/tiny-spring分析/">https://zakariyya.github.io/2018/03/18/backEnd/spring/tiny-spring分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/03/18/backEnd/spring/tiny-spring 简介/"><i class="fa fa-chevron-left">  </i><span>tiny-spring 简介</span></a></div><div class="next-post pull-right"><a href="/2018/03/14/碎碎念/我未曾见过你, 而你的光却照耀到了我/"><span>我未曾见过你，而你的光却照耀到了我</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://zakariyya.github.io/2018/03/18/backEnd/spring/tiny-spring分析/';
  this.page.identifier = '2018/03/18/backEnd/spring/tiny-spring分析/';
  this.page.title = 'tiny-spring 分析';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'H2O2' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://H2O2.disqus.com/count.js" async></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By anan</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>